# to recover individual items, csh this file
#=======================================================================
mkdir ./d
mkdir ./e
mkdir ./f
mkdir ./i
mkdir ./o
#=======================================================================
echo aide-memoire
cat >aide-memoire <<"ENDOF aide-memoire"

Data preparation
----------------

- Move to ./d/

      *  Put in this directory the EM map, extract the box for fitting (the
         EM box), and transform it into EZD format. The EM box must be assigned
         to name "emap.d". Create a symbolic link between the EM box and this
         name, e.g.
             ln -sf EM_box.ezd emap.d
      *  Create two files containing the symmetry operators of the EM image:
         "gs.sym" (O format) and "sym" (URO format). For simple point groups
         you may adapt the example generated by executing the script "d7.scr".
      *  Put in this directory the PDB files corresponding to the independent
         search models. Insert a FORMAT card ("fmt" file) at the head of these
         files.
      *  Model coordinates are identified by numbers. The PDB files must be
         assigned to names "xyz{n}.d" (n: model identification number). Create
         symbolic links between the model files and the names required by the
         program, e.g.
             ln -sf VP1.pdb xyz1.d
             ln -sf VP7.pdb xyz2.d
      *  Define the resolution limits (in Angstroms) in the file "data.d".

- Back to working directory ./

      *  Fourier transform the EM box:
            e/emft [ezd-map] [scale]

      *  Compute the molecular scattering factors for each of the search
         models:
            e/scat [n]

      *  Extract a region of the EM box ("d/emap.d") for graphic use. It must be
         named "box.ezd". You may use the script "$URO/$BIN/e2e".

      *  Create the PDB files corresponding to the independent molecules in
         their initial positions within the EM box, e.g. "VP1_1.pdb",
         "VP1_2.pdb", "VP7_1.pdb", where "VP1_1.pdb" and "VP1_2.pdb" are
         rotated and translated copies of "d/xyz1.d", and "VP7_1.pdb" is a
         rotated and translated copy of "d/xyz2.d".

      *  Create "modlist" file with molecule names assigned to model numbers,
         e.g.
cat > modlist <<"EOF"
# 1 VP1_1 VP1_2
# 2 VP7_1
"EOF"

Protocol
--------

Programs are executed from the working directory (./).

- Initial positional variables of the independent molecules:
            e/c2pv [X]

- Create "symlist" file (and "box.sym" to check on the graphics):
            e/ctl [X]

- Prepare the input file for the optimization program:
            e/oic [X] [fit] {cycles}
  Note: usually, cycles = number of independent molecules to fit
        (see the writeup).

- Run the optimization program FITING:
            e/fiting [fit] [Y]
  Both steps may be performed in a single run by executing
            e/oic_fiting [X] [Y] {cycles}

- Iteration:
            e/oic_fitting [Y-inp] [Y-out]

- Generation of optimized coordinates:
            e/pv2c [Y]

- Macro file for visualizing final results with the program O:
            go.O or go_instance.O

- Change to lower resolution: modify the resolution limits in file
  "d/data.d" and execute:
            e/job

- Problems:
  Fix dimensions and reading options in file "e/maitre.scr" and create new
  executables:
            csh e/maitre.scr

"ENDOF aide-memoire"
#=======================================================================
echo go.MASK
cat >go.MASK <<"ENDOF go.MASK"
#!/bin/csh -f
# ======================================================================
   if($#argv != 1) then
echo "Usage: {go.MASK} d/{output-ezd-map}" ; exit
   endif
set MAPOUT=d/${1}
#****************** needs MODlist and SYMlist **************************
   if(! -e modlist || ! -e symlist) then
echo "NEED modlist AND symlist FILES" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
awk -f LisT1 LisT >! listmod
rm -rf LisT LisT1

# ======================================================================
source ${PROGS}/ccp4.setup

# ======================================================================
set SYM=d/sym
sed -e "s/^[ ]*[0-9]*//" listmod >! LisT
echo -n                                              >! CORDS.INP
   foreach MOL (`cat LisT`)
      foreach sym (`cat symlist`)
echo "${MOL}.pdb"                                    >> CORDS.INP
echo "${MOL}_${sym}.pdb"                             >> CORDS.INP
echo "n"                                             >> CORDS.INP
egrep -e "#${sym}"$ $SYM                             >> CORDS.INP
echo "n"                                             >> CORDS.INP
      end
   end
echo ""                                              >> CORDS.INP
$URO/$BIN/cords < CORDS.INP >/dev/null
rm -f CORDS.INP
echo -n >! BoXca.pdb
   foreach MOL (`cat LisT`)
      foreach sym (`cat symlist`)
grep "CA" ${MOL}_${sym}.pdb  >> BoXca.pdb
rm -f ${MOL}_${sym}.pdb
      end
   end
rm -f LisT listmod

# ======================================================================
set cell=`grep CELDA d/data.d | sed -e "s/CELDA//"`
set grid=`head -20 d/emap.d | grep EXTENT | sed -e "s/EXTENT/GRID/"`
echo `head -20 d/emap.d | grep ORIGIN` `head -20 d/emap.d | grep EXTENT` >! LisT
awk '{printf "XYZLIM  %4d %4d %4d %4d %4d %4d\n",$2,$2+$6-1,$3,$3+$7-1,$4,$4+$8-1}' LisT >! LisT1
set xyzlim=`cat LisT1`
rm -f LisT LisT1

# ======================================================================
pdbset XYZIN BoXca.pdb XYZOUT BoX.pdb <<EOF
CELL ${cell}
NCODE 1
END
EOF
rm -f BoXca.pdb

# ======================================================================
ncsmask xyzin BoX.pdb mskout BoX.msk <<EOF
CELL ${cell}
${grid}
${xyzlim}
SYMMETRY P1
AXIS Y X Z
RADIUS 10.0
EXPAND -5.0
NOTRIM
END
EOF
rm -f BoX.pdb

# ======================================================================
#mama2ccp4 MASKIN BoX.msk MASKOUT box.mask

# ======================================================================
mapman <<"EOF"
read map d/emap.d
NEWEZD
write map BoXe.ccp4
CCP4
quit
"EOF"

# ======================================================================
mapmask MAPIN BoXe.ccp4 MSKIN2 BoX.msk MAPOUT BoX.ccp4 <<"EOF"
SOLVE
END
"EOF"
rm -f BoXe.ccp4 BoX.msk

# ======================================================================
if(-e ${MAPOUT}) rm -f ${MAPOUT}
mapman <<EOF
read map BoX.ccp4
CCP4
write map ${MAPOUT}
NEWEZD
quit
EOF
rm -f BoX.ccp4
exit
"ENDOF go.MASK"
#=======================================================================
echo go.O
cat >go.O <<"ENDOF go.O"
#!/bin/csh -f
# ======================================================================
   if(! -e box.ezd) then
echo "NEED box.ezd FILE" ; exit
   endif
set symlist=box.sym
# ======================================================================
# pour deplacer une molecule ou fragment:
# faire mol [nom de l'Object](figure dans Objects)]
# faire Move_zone et suivre les indications
# ou Move_zone [first atom] [last atom]
# activer Fake-dials et bouger soit le fragment soit le dessin
# a la fin faire Yes, ensuite s_a_o et suivre les indications

# para borrar objetos:
# en menu Display, activar delete object

# para recuperar gs.real hacer:
# write .gs_real
# > gs.real
# > RETURN
# ======================================================================
echo `egrep -e "CELL|ORIGIN|EXTENT|GRID" box.ezd` >! LisT
set OX=`awk '{printf "%10.3f\n",$9*$2/$17}' LisT`
set OY=`awk '{printf "%10.3f\n",$10*$3/$18}' LisT`
set OZ=`awk '{printf "%10.3f\n",$11*$4/$19}' LisT`
set X=`awk '{printf "%10.3f\n",($9+$13-1)*$2/$17}' LisT`
set Y=`awk '{printf "%10.3f\n",($10+$14-1)*$3/$18}' LisT`
set Z=`awk '{printf "%10.3f\n",($11+$15-1)*$4/$19}' LisT`
set OXS=`awk '{printf "%10.3f\n",($13/1)*$2/$17}' LisT`
set OYS=`awk '{printf "%10.3f\n",($14/1)*$3/$18}' LisT`
set OZS=`awk '{printf "%10.3f\n",($15/1)*$4/$19}' LisT`
rm -f LisT
cat >! box <<EOF
box T 36 72
begin_object box
line_type solid
text_size 1.0
colour white
text 0 0 0 o
colour blue
move 0 0 0
line $OXS 0 0
colour white
move 0 0 0
line 0 $OYS 0
colour red
move 0 0 0
line 0 0 $OZS
colour yellow
move $OX $OY $OZ
line $X $OY $OZ
line $X $Y $OZ
line $OX $Y $OZ
line $OX $OY $OZ
line $OX $OY $Z
line $X $OY $Z
line $X $Y $Z
line $OX $Y $Z
line $OX $OY $Z
move $X $OY $OZ
line $X $OY $Z
move $X $Y $OZ
line $X $Y $Z
move $OX $Y $OZ
line $OX $Y $Z
text $OX $OY $OZ O
text $X $OY $OZ X
text $OX $Y $OZ Y
text $OX $OY $Z Z
end_object box
EOF
# ======================================================================
echo -n                                                  >! ono
echo "read d/gs.sym"                                     >> ono
echo ""                                                  >> ono
echo "read box"                                          >> ono
echo "draw_object box"                                   >> ono
echo ""                                                  >> ono
echo "@box.ezd"                                          >> ono
echo "e-d"                                               >> ono
echo "1.5"                                               >> ono
echo "steel_blue"                                        >> ono
# ======================================================================
   if(! -e modlist || ! -e ${symlist}) then
echo "NEED modlist AND ${symlist} FILES" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
awk -f LisT1 LisT >! listmod
rm -rf LisT LisT1
# ======================================================================
sed -e "s/^[ ]*[0-9]*//" listmod >! LisT
   foreach MOL (`cat LisT`)
                 set COL=white
if(${MOL} =~ A*) set COL=red
if(${MOL} =~ B*) set COL=yellow
if(${MOL} =~ C*) set COL=green
if(${MOL} =~ D*) set COL=orange
if(${MOL} =~ E*) set COL=red
if(${MOL} =~ F*) set COL=yellow
if(${MOL} =~ M*) set COL=green
if(${MOL} =~ P*) set COL=orange
if(${MOL} =~ T*) set COL=red
if(${MOL} =~ V*) set COL=yellow
if(${MOL} =~ *p) set COL=white
echo ""                                                  >> ono
echo "s-a-i ${MOL}.pdb ${MOL}"                           >> ono
echo "mol ${MOL}"                                        >> ono
echo "paint-zone ; ; ${COL}"                             >> ono
echo "ca ; end"                                          >> ono
      foreach sym (`cat ${symlist}`)
echo "object ${MOL}_${sym} ca ; end"                     >> ono
echo "lsq_object sym${sym} ${MOL}_${sym}"                >> ono
      end
   end
echo ""                                                  >> ono
echo "read gs.real"                                      >> ono
rm -f LisT listmod
exit
"ENDOF go.O"
#=======================================================================
echo go_instance.O
cat >go_instance.O <<"ENDOF go_instance.O"
#!/bin/csh -f
# ======================================================================
   if(! -e box.ezd) then
echo "NEED box.ezd FILE" ; exit
   endif
set symlist=box.sym
# ======================================================================
# pour deplacer une molecule ou fragment:
# faire mol [nom de l'Object](figure dans Objects)]
# faire Move_zone et suivre les indications
# ou Move_zone [first atom] [last atom]
# activer Fake-dials et bouger soit le fragment soit le dessin
# a la fin faire Yes, ensuite s_a_o et suivre les indications

# para borrar objetos:
# en menu Display, activar delete object

# para recuperar gs.real hacer:
# write .gs_real
# > gs.real
# > RETURN
# ======================================================================
echo `egrep -e "CELL|ORIGIN|EXTENT|GRID" box.ezd` >! LisT
set OX=`awk '{printf "%10.3f\n",$9*$2/$17}' LisT`
set OY=`awk '{printf "%10.3f\n",$10*$3/$18}' LisT`
set OZ=`awk '{printf "%10.3f\n",$11*$4/$19}' LisT`
set X=`awk '{printf "%10.3f\n",($9+$13-1)*$2/$17}' LisT`
set Y=`awk '{printf "%10.3f\n",($10+$14-1)*$3/$18}' LisT`
set Z=`awk '{printf "%10.3f\n",($11+$15-1)*$4/$19}' LisT`
set OXS=`awk '{printf "%10.3f\n",($13/1)*$2/$17}' LisT`
set OYS=`awk '{printf "%10.3f\n",($14/1)*$3/$18}' LisT`
set OZS=`awk '{printf "%10.3f\n",($15/1)*$4/$19}' LisT`
rm -f LisT
cat >! box <<EOF
box T 36 72
begin_object box
line_type solid
text_size 1.0
colour white
text 0 0 0 o
colour blue
move 0 0 0
line $OXS 0 0
colour white
move 0 0 0
line 0 $OYS 0
colour red
move 0 0 0
line 0 0 $OZS
colour yellow
move $OX $OY $OZ
line $X $OY $OZ
line $X $Y $OZ
line $OX $Y $OZ
line $OX $OY $OZ
line $OX $OY $Z
line $X $OY $Z
line $X $Y $Z
line $OX $Y $Z
line $OX $OY $Z
move $X $OY $OZ
line $X $OY $Z
move $X $Y $OZ
line $X $Y $Z
move $OX $Y $OZ
line $OX $Y $Z
text $OX $OY $OZ O
text $X $OY $OZ X
text $OX $Y $OZ Y
text $OX $OY $Z Z
end_object box
EOF
# ======================================================================
echo -n                                                  >! ono
echo "read d/gs.sym"                                     >> ono
echo ""                                                  >> ono
echo "read box"                                          >> ono
echo "draw_object box"                                   >> ono
echo ""                                                  >> ono
echo "@box.ezd"                                          >> ono
echo "e-d"                                               >> ono
echo "1.5"                                               >> ono
echo "steel_blue"                                        >> ono
# ======================================================================
   if(! -e modlist || ! -e ${symlist}) then
echo "NEED modlist AND ${symlist} FILES" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
awk -f LisT1 LisT >! listmod
rm -rf LisT LisT1
# ======================================================================
sed -e "s/^[ ]*[0-9]*//" listmod >! LisT
   foreach MOL (`cat LisT`)
echo "begin_object ${MOL}_i"             >! ${MOL}_i.odl
      foreach sym (`cat ${symlist}`)
echo "instance ${MOL} .LSQ_RT_SYM"${sym} >> ${MOL}_i.odl
      end
echo "end_object ${MOL}_i"               >> ${MOL}_i.odl
                 set COL=white
if(${MOL} =~ A*) set COL=red
if(${MOL} =~ B*) set COL=yellow
if(${MOL} =~ C*) set COL=green
if(${MOL} =~ D*) set COL=orange
if(${MOL} =~ E*) set COL=red
if(${MOL} =~ F*) set COL=yellow
if(${MOL} =~ M*) set COL=green
if(${MOL} =~ P*) set COL=orange
if(${MOL} =~ T*) set COL=red
if(${MOL} =~ V*) set COL=yellow
if(${MOL} =~ *p) set COL=white
echo ""                                                  >> ono
echo "s-a-i ${MOL}.pdb ${MOL}"                           >> ono
echo "mol ${MOL}"                                        >> ono
echo "paint-zone ; ; ${COL}"                             >> ono
echo "ca ; end"                                          >> ono
echo "draw_object ${MOL}_i.odl"                          >> ono
   end
echo ""                                                  >> ono
echo "read gs.real"                                      >> ono
rm -f LisT listmod

exit
"ENDOF go_instance.O"
#=======================================================================
echo go.PDBSYM
cat >go.PDBSYM <<"ENDOF go.PDBSYM"
#!/bin/csh -f
# ======================================================================
   if($#argv != 2) then
echo "Usage: {go.PDBSYM} {symlist} {CA|ALL}" ; exit
   endif
set symlist=$1
#****************** needs MODlist and SYMlist **************************
   if(! -e modlist || ! -e ${symlist}) then
echo "NEED modlist AND ${symlist} FILES" ; exit
   endif
# ======================================================================
setenv SYM d/sym
grep "\#" modlist | sed -e "s/#[ ]*[0-9]*//" >! LisT

   foreach MOL (`cat LisT`)
      if(${1} == "CA" || ${1} == "ca" || ${1} == "Ca") then
egrep -e "^FORMAT| CA" ${MOL}.pdb >! ${MOL}_mod.pdb
      else
egrep -e "^FORMAT|^ATOM" ${MOL}.pdb >! ${MOL}_mod.pdb
      endif
   end

echo -n                                              >! CORDS.INP
   foreach MOL (`cat LisT`)
      foreach sym (`cat ${symlist}`)
echo "${MOL}_mod.pdb"                                >> CORDS.INP
echo "${MOL}_${sym}.pdb"                             >> CORDS.INP
echo "n"                                             >> CORDS.INP
egrep -e "#${sym}"$ $SYM                             >> CORDS.INP
echo "n"                                             >> CORDS.INP
      end
   end
echo ""                                              >> CORDS.INP

$URO/$BIN/cords < CORDS.INP >/dev/null
rm -f CORDS.INP
   foreach MOL (`cat LisT`)
grep "^FORMAT" ${MOL}_mod.pdb >! FmT
rm -f ${MOL}_mod.pdb
   end

# ======================================================================
echo -n >! MULTI.pdb
   foreach MOL (`cat LisT`)
cat FmT >> MULTI.pdb
      foreach sym (`cat ${symlist}`)
sed -e "/^FORMAT/d" ${MOL}_${sym}.pdb >> MULTI.pdb
echo "TER" >> MULTI.pdb
rm -f ${MOL}_${sym}.pdb
      end
   end
rm -f LisT FmT

# ======================================================================
cat > prg.for <<"ENDOF"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program formpdb
      implicit none
      integer ato,cha,lin,res
      character b*1,card*80,chain*1,residue*4,string*1
      dimension string(52)
      data string/'A','B','C','D','E','F','G','H','I','J','K','L','M',
     & 'N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c',
     & 'd','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s',
     & 't','u','v','w','x','y','z'/
      b=' '
      lin=0
      ato=0
      res=0
      cha=0
      residue='   '
      open(unit=1,file='MULTI.pdb',form='formatted',status='old')
      open(unit=2,file='SYMET.pdb',form='formatted')
c
c '         1         2         3         4         5         6         7      '
c '1234*678901*3456*890*2*456789*1234567890123456789012345678901234567890123456'
c 'ATOM|     1| CB |MET|A|001   |  19.227  22.787   2.598  1.00 49.67   6      '
c
10    read(1,fmt='(a80)',end=20) card
      lin=lin+1
         if(card(1:4).ne.'ATOM') then
      write(2,'(a)') card
            if(card(1:6).eq.'FORMAT'.or.card(1:3).eq.'TER') then
      cha=cha+1
      cha=mod(cha,53)
      chain=string(cha)
      res=0
            endif
      go to 10
         endif
         if(card(5:5).ne.b.or.card(12:12).ne.b.or.card(17:17).ne.b.or.
     . card(21:21).ne.b.or.card(23:23).ne.b.or.card(30:30).ne.b) then
      card(5:5)=b
      card(12:12)=b
      card(17:17)=b
      card(21:21)=b
      card(23:23)=b
      card(30:30)=b
cjn   write(6,'(A,i6)') 'CONTIGUOUS line:',lin
         endif
      ato=ato+1
      write(card(6:11),'(i6)') ato
      card(22:22)=chain
         if(card(18:20).ne.residue) then
      residue=card(18:20)
      res=res+1
         endif
      write(card(24:29),'(i4,a2)') res,'  '
      write(2,'(a)') card
      go to 10
20    stop
      end
"ENDOF"
f77 prg.for -o prg.exe
prg.exe
/bin/rm -f prg.for prg.exe MULTI.pdb
exit
"ENDOF go.PDBSYM"
#=======================================================================
echo ncs_rms
cat >ncs_rms <<"ENDOF ncs_rms"
#!/bin/csh -f
# ======================================================================
   if($#argv != 1) then
echo "Usage: {ncs_rms} o/{fiting-out}.s" ; exit
   endif
   if(! -e o/${1}.s) then
echo "No fiting output with this name = o/${1}.s" ; exit
   endif
   if(! -e modlist) then
echo "NEED modlist FILE" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
set num=`awk -f LisT1 LisT | sed -e "s/^[ ]*[0-9]*//" | wc -w`
rm -rf LisT LisT1
# ======================================================================
source $URO/$BIN/entorno
date +"%T" | sed -e "s/\://g" >! seed

ln -s $cwd/d/data.d $UROF/fort.10
ln -s $cwd/o/$1.s $UROF/fort.11
ln -s $cwd/seed $UROF/fort.12
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 20`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
echo ""
echo " Final result from fiting (file ${1}.s):"
echo ""
grep " #" $UROF/fort.11

$URO/$BIN/ncsrms.exe

mv $UROF/fort.13 $cwd/o/rms0.s

echo " Now running fitting for the different trials"
e/oic rms0 fit ${num}
e/fiting fit rms1 >> $UROF/log_rms

head -1 $cwd/o/rms0.s >! $UROF/temp1
sed -e "/fiting/d" $cwd/o/rms1.s >! $UROF/temp2
cat $UROF/temp1 $UROF/temp2 >! $cwd/o/rms1.s

$URO/$BIN/propre rms1 3.0

egrep -e "r-m-s shifts:|cumulated|^ \#" $UROF/log_rms >> $UROF/log_rms1
ln -s $UROF/log_rms1 $UROF/fort.13

# ======================================================================
cat >! prg.f <<"ENDOF prg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program prog
      implicit none
      integer i,ie,ih,io,itbody
      character lun*80,lun1*80
      logical run,run1
      ie = 11
      ih = 13
      io = 6
      call abra (ie,'f','u',0)
      rewind(ie)
      read(ie,*)
      read(ie,*)itbody
      call abra (ih,'f','u',0)

      run = .true.
      do while (run)
       do i=1,itbody
        read(ih,'(a80)',end=100)lun
        if(i.eq.1) then
          write(io,10)
 10       format (/,1x,35('*+'),//,1x,'Initial positions:')
        endif
        write(io,'(a80)')lun
       enddo
       run1 = .true.
       i = 0
       do while (run1)
        read(ih,'(a80)',end=100)lun1
        if(lun1(2:10).eq.'cumulated') then
          write(io,*)
          write(io,'(a80)')lun
          write(io,'(a80)')lun1
          i = i + 1
          if(i.eq.itbody) run1 = .false.
        else
          lun = lun1
        endif
       enddo
       write(io,20)
 20    format (/,1x,'Final positions:')
       do i=1,itbody
        read(ih,'(a80)',end=100)lun
        write(io,'(a80)')lun
       enddo
      enddo

 100  run = .false.
      stop
      end
"ENDOF prg.f"
# ======================================================================
$COMPILE prg.f $URO/$BIN/esclave.a -o prg.exe
./prg.exe >/dev/null
rm -rf prg.f prg.exe $UROF
exit
"ENDOF ncs_rms"
#=======================================================================
echo splits
cat >splits <<"ENDOF splits"
#!/bin/csh -f
# splits *************************************
   if($#argv != 2) then
echo "Usage: {splits} o/{fiting-in}.s o/{fiting-out}.s" ; exit
   endif
source $URO/$BIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
ln -s $cwd/o/${1}.s $UROF/fort.1
ln -s $cwd/o/${2}.s $UROF/fort.9
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$URO/$BIN/splits.exe <<EOF
#1 > #4 #5 #6
EOF
rm -rf $UROF
exit
"ENDOF splits"
#=======================================================================
echo d/d7.scr
cat >d/d7.scr <<"ENDOF d/d7.scr"
#!/bin/csh -f
# ======================================================================
cat >! prg.f <<"ENDOF prg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program d7
      implicit none
      integer L,i,j,length
      double precision alpha,beta,cosa,dang,dtor,gamma,pi,rotx,rtod,
     & sina,twopi,u
      character card*80,cart*80
      external length
      dimension rotx(3,3),u(3)
      common/angkte/ pi,twopi,dtor,rtod
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=pi*2.d0
      dtor=pi/180.d0
      rtod=180.d0/pi

c========================
      open(unit=1,file='sym',form='formatted',status='unknown')
      open(unit=2,file='gs.sym',form='formatted',status='unknown')
       do i=1,80
      card(i:i)=' '
      cart(i:i)=' '
       enddo
      card(65:65)='#'
      cart(1:40)='.LSQ_RT_SYM       R     12  (3F12.6)    '

      L=0
      do 10 j=0,6
      dang=j*twopi/7.
      cosa=cos(dang)
      sina=sin(dang)
      card(66:70)='     '
      cart(12:16)='     '
      write(card(1:60),'(6f10.3)') j*360.d0/7.,0.,0.,0.,0.,0.
      L=L+1
         if(L.lt.10) then
      write(card(66:66),'(i1)') L
      write(cart(12:12),'(i1)') L
         else if(L.lt.100) then
      write(card(66:67),'(i2)') L
      write(cart(12:13),'(i2)') L
         else
      write(card(66:68),'(i3)') L
      write(cart(12:14),'(i3)') L
         endif
      write(1,'(a)') card(1:length(card))
      write(2,'(a)') cart(1:length(cart))
      write(2,'(3f12.6)') cosa,sina,0.
      write(2,'(3f12.6)') -sina,cosa,0.
      write(2,'(3f12.6)') 0.,0.,1.
      write(2,'(3f12.6)') 0.,0.,0.
10    continue

      do 20 j=0,6
      dang=j*twopi/7.
      u(1)=cos(dang)
      u(2)=sin(dang)
      u(3)=0.d0
      call rmxp(180.d0,u,rotx)
      call rmx2e(rotx,alpha,beta,gamma)
      card(66:70)='     '
      cart(12:16)='     '
      write(card(1:60),'(6f10.3)') alpha,beta,gamma,0.,0.,0.
      L=L+1
         if(L.lt.10) then
      write(card(66:66),'(i1)') L
      write(cart(12:12),'(i1)') L
         else if(L.lt.100) then
      write(card(66:67),'(i2)') L
      write(cart(12:13),'(i2)') L
         else
      write(card(66:68),'(i3)') L
      write(cart(12:14),'(i3)') L
         endif
      write(1,'(a)') card(1:length(card))
      write(2,'(a)') cart(1:length(cart))
      write(2,'(3f12.6)') (rotx(1,i),i=1,3)
      write(2,'(3f12.6)') (rotx(2,i),i=1,3)
      write(2,'(3f12.6)') (rotx(3,i),i=1,3)
      write(2,'(3f12.6)') 0.,0.,0.
20    continue

c========================
      stop
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function length(card)
      implicit none
      integer i,length
      character card*80
       do i=80,1,-1
      if(card(i:i).ne.' ') go to 10
       enddo
10    length=i
      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2e(rotx,alpha,beta,gamma)
      implicit none
      double precision alpha,ang,beta,cang,dtor,fuzz,gamma,pi,rotx,rtod,
     & sang,twopi
      dimension rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      fuzz=0.001
      cang=sqrt(min(max(2.d0-(rotx(1,3)**2+rotx(2,3)**2+rotx(3,1)**2+
     . rotx(3,2)**2+rotx(3,3)**2),0.d0),1.d0))
      ang=acos(sign(cang,rotx(3,3)))
      sang=sin(ang)
         if(sang.gt.fuzz) then
      alpha=rtod*atan2(rotx(2,3),rotx(1,3))
      gamma=rtod*atan2(rotx(3,2),-rotx(3,1))
         else
      alpha=rtod*atan2(-rotx(1,2),rotx(1,1)*rotx(3,3))
      gamma=0.
         endif
      alpha=mod(360+alpha,360.d0)
      beta=rtod*ang
      gamma=mod(360+gamma,360.d0)
      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxp(xhi,vn,rotp)
      implicit none
      integer eijk,i,j,k
      double precision ang,cang,dtor,pi,rotp,rtod,sang,twopi,vn,xhi
      dimension eijk(3,3,3),rotp(3,3),vn(3)
      common/angkte/ pi,twopi,dtor,rtod
      data eijk/
     & 0,0,0,0,0,-1,0,1,0,0,0,1,0,0,0,-1,0,0,0,-1,0,1,0,0,0,0,0/
      ang=dtor*xhi
      cang=cos(ang)
      sang=sin(ang)
      do 30 j=1,3
      do 20 i=1,3
      rotp(i,j)=(1-cang)*vn(i)*vn(j)
      if(i.eq.j) rotp(i,j)=rotp(i,j)+cang
      do 10 k=1,3
         if(eijk(i,k,j).gt.0) then
      rotp(i,j)=rotp(i,j)+sang*vn(k)
         else if(eijk(i,k,j).lt.0) then
      rotp(i,j)=rotp(i,j)-sang*vn(k)
         endif
10    continue
20    continue
30    continue
      return
      end
"ENDOF prg.f"
$COMPILE prg.f -o prg.exe
./prg.exe
rm -f prg.f prg.exe
exit
"ENDOF d/d7.scr"
#=======================================================================
echo d/data.d
cat >d/data.d <<"ENDOF d/data.d"
 ** URO **
1. 1. 1. 90. 90. 90. CELDA
x,y,z * stop
1                   ; orthogonalising code (PDB setting)
100    0.           ; % reflections, b-add
400.   15.          ; resolution range
"ENDOF d/data.d"
#=======================================================================
echo d/fmt
cat >d/fmt <<"ENDOF d/fmt"
FORMAT  (12x,a4,14x,3f8.3,6x,f6.2)
"ENDOF d/fmt"
#=======================================================================
echo d/o2u.scr
cat >d/o2u.scr <<"ENDOF d/o2u.scr"
#!/bin/csh -f
   if(! -e gs.sym) then
echo "O symmetry operations filename must be named gs.sym"
echo "gs.sym file does not exist" ; exit
   endif
# ======================================================================
cat >! prg.f <<"ENDOF prg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program o2u
      implicit none
      integer i,j,length,n
      double precision alpha,beta,dtor,gamma,pi,rtod,symop,twopi,xt
      character card*80
      external length
      dimension symop(3,3),xt(3)
      common/angkte/ pi,twopi,dtor,rtod
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=pi*2.d0
      dtor=pi/180.d0
      rtod=180.d0/pi

c========================
      open(unit=1,file='gs.sym',form='formatted',status='unknown')
      open(unit=2,file='sym',form='formatted',status='unknown')
c========================

      n=0
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
10    read(1,*,end=20)
       do i=1,3
      read(1,*) (symop(j,i),j=1,3)
       enddo
      read(1,*) xt
      call rmx2e(symop,alpha,beta,gamma)
      write(card(1:60),'(6f10.3)') alpha,beta,gamma,xt
      card(66:68)='   '
      n=n+1
         if(n.lt.10) then
      write(card(66:66),'(i1)') n
         else if(n.lt.100) then
      write(card(66:67),'(i2)') n
         else
      write(card(66:68),'(i3)') n
         endif
      write(2,'(a)') card(1:length(card))
      go to 10
20    stop
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function length(card)
      implicit none
      integer i,length
      character card*80
       do i=80,1,-1
      if(card(i:i).ne.' ') go to 10
       enddo
10    length=i
      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2e(rotx,alpha,beta,gamma)
      implicit none
      double precision alpha,ang,beta,cang,dtor,fuzz,gamma,pi,rotx,rtod,
     & sang,twopi
      dimension rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      fuzz=0.001
      cang=sqrt(min(max(2.d0-(rotx(1,3)**2+rotx(2,3)**2+rotx(3,1)**2+
     . rotx(3,2)**2+rotx(3,3)**2),0.d0),1.d0))
      ang=acos(sign(cang,rotx(3,3)))
      sang=sin(ang)
         if(sang.gt.fuzz) then
      alpha=rtod*atan2(rotx(2,3),rotx(1,3))
      gamma=rtod*atan2(rotx(3,2),-rotx(3,1))
         else
      alpha=rtod*atan2(-rotx(1,2),rotx(1,1)*rotx(3,3))
      gamma=0.
         endif
      alpha=mod(360+alpha,360.d0)
      beta=rtod*ang
      gamma=mod(360+gamma,360.d0)
      return
      end
"ENDOF prg.f"
# ======================================================================
$COMPILE prg.f -o prg.exe
./prg.exe
rm -f prg.f prg.exe
exit
"ENDOF d/o2u.scr"
#=======================================================================
echo e/c2pv
cat >e/c2pv <<"ENDOF e/c2pv"
#!/bin/csh -f
# ======================================================================
   if($#argv != 1) then
echo "Usage: {e/c2pv} o/{fiting-out}.s" ; exit
   endif
#****************** needs MODlist **************************************
   if(! -e modlist) then
echo "NEED modlist FILE" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
awk -f LisT1 LisT >! listmod
rm -rf LisT LisT1

# ======================================================================
cat >! LisT <<"EOF"
BEGIN { printf "%-3d\n", 1 ; printf "%-3d\n", 1 }
{ printf "%-3d\n", $1 }
END { printf "%-3d\n", 0 }
"EOF"
awk -f LisT listmod >! LisT1
$URO/$BIN/origen < LisT1 >/dev/null
rm -rf LisT LisT1

# ======================================================================
echo "0"                                             >! RMSQ.INP
cat >! LisT <<"EOF"
{ for(j=2 ; j<NF ; j++)
 { printf "%s.pdb \n",$j ; printf "mol%-3d\n",$1 }
}
{ printf "%s.pdb \n",$NF ; printf "mol%-3d\n",$1 }
"EOF"
awk -f LisT listmod                                  >> RMSQ.INP
echo ""                                              >> RMSQ.INP

$URO/$BIN/rmsq < RMSQ.INP >! RMSQ.OUT
rm -f LisT RMSQ.INP mol*

set STOP=`awk '{if($1 ~ /stop/){print 1}}' RMSQ.OUT`
   if($STOP == 1) then
echo " >> INCOMPATIBLE MODELS. FIX AND RUN e/c2pv << "
grep "stop" RMSQ.OUT
rm -f listmod RMSQ.OUT ; exit
   endif

grep "warning" RMSQ.OUT | head -1 >! LisT
set STOP=`awk '{if($2 ~ /warning/){print 1}}' LisT`
   if($STOP == 1) then
echo " >> INCOMPATIBLE MODELS. FIX AND RUN e/c2pv << "
grep "warning" RMSQ.OUT
rm -f listmod RMSQ.OUT LisT ; exit
   endif

awk '{for(j=2 ; j<=NF ; j++) printf " #%2d\n", $1}' listmod >! LisT1
grep "transformation" RMSQ.OUT | \
sed -e "s/transformation (+M,T)://" >! LisT2
paste LisT1 LisT2 >! LisT3
echo `wc LisT1 | awk '{print $1}'` >! LisT
cat LisT3 >> LisT
rm -f listmod LisT1 LisT2 LisT3 RMSQ.OUT

# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
ln -s $cwd/o/${1}.s $UROF/fort.9
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl${n}.s) then
set m=`expr $n + 10`
sed -e "/mass :/s/[0-9]/0/g" $cwd/o/tabl${n}.s | \
sed -e "/rotation/s/[0-9]/0/g" >! $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$URO/$BIN/ci2rm.exe < LisT
rm -rf LisT $UROF
exit
"ENDOF e/c2pv"
#=======================================================================
echo e/ctl
cat >e/ctl <<"ENDOF e/ctl"
#!/bin/csh -f
# ======================================================================
   if($#argv < 1) then
echo "Usage: {e/ctl} o/{fiting-out}.s [new]" ; exit
   endif
   if(! -e o/${1}.s) then
echo "No fiting output with this name = o/${1}.s" ; exit
   endif
   if(! -e d/emap.d) then
echo "NEED d/emap.d LINK" ; exit
   endif
set SYM=d/sym
set MAP=d/emap.d
set symlist="symlist"
   if($#argv == 2 || ! -e ${symlist}) then
echo "generating ${symlist} file"
echo -n >! ${symlist}
set num=`wc $SYM` ; set num=$num[1]
set n="1"
      while ($n <= $num)
echo $n >> ${symlist}
set n=`expr $n + 1`
      end
   else
echo "checking ${symlist} file"
   endif

#****************** needs MODlist **************************************
   if(! -e modlist) then
echo "NEED modlist FILE" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
awk -f LisT1 LisT >! listmod
rm -rf LisT LisT1

# ======================================================================
# generates symmetry operations to apply to the independent molecules in
# the working cell. transforms symmetry operations into fractional and
# subtracts the origin.

echo `grep "CELDA" d/data.d` `head -20 ${MAP} | egrep -e "ORIGIN|EXTENT"` >! LisT
cat >! LisT1 <<"EOF"
{ printf "A=%8.3f;B=%8.3f;C=%8.3f;TX=%3d/%-3d;TY=%3d/%-3d;TZ=%3d/%-3d\n",\
 $1,$2,$3,$9,$13,$10,$14,$11,$15 }
"EOF"
awk -f LisT1 LisT |sed -e "s/\//\\\//g" >! LisT2
set line=`cat LisT2`
rm -f LisT LisT1 LisT2

echo -n >! LisT1
set num="0"
   foreach sym (`cat ${symlist}`)
egrep -e "#${sym}"$ $SYM >> LisT1
set num=`expr ${num} + 1`
   end

sed -e "/LINE/s/LINE/${line}/" <<"EOF" |sed -e "/NUMB/s/NUMB/${num}/" >! LisT2
BEGIN { LINE ; printf "ncs %5d\n",NUMB }
{ printf " %8.2f%8.2f%8.2f%10.5f%10.5f%10.5f      %s\n", \
       $1,$2,$3,$4/A-TX,$5/B-TY,$6/C-TZ,$7 }
"EOF"
awk -f LisT2 LisT1 >! LisT
rm -f LisT1 LisT2

# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
ln -s $cwd/o/${1}.s $UROF/fort.1
$URO/$BIN/ncsctl.exe < LisT >! LisT1

sed -e "s/^[ ]*[0-9]*//" listmod | wc -w >! LisT2

cat >! prg.f <<"ENDOF prg.f"
      program ctl
      implicit none
      integer count,nsym,num
      character flag*1
      logical logic
      dimension count(500)
      open(unit=10,file='LisT1',status='old')
       do nsym=1,500
      count(nsym)=0
       enddo
      logic=.true.
       do while (logic)
      read(10,fmt='(54x,i5,2x,a1)',end=100) nsym,flag
         if(flag .ne. '*') then
      count(nsym)=count(nsym)+1
         endif
       enddo
100   open(unit=11,file='LisT2',status='old')
      read(11,*) num
      open(unit=20,file='gen.symlist',status='unknown')
       do nsym=1,500
         if(count(nsym).eq.num) then
      write(20,*) nsym
         endif
       enddo
      stop
      end
"ENDOF prg.f"
$COMPILE prg.f -o prg.exe
./prg.exe
rm -rf prg.f prg.exe ${symlist} listmod LisT LisT1 LisT2 $UROF
mv gen.symlist ${symlist}
exit
"ENDOF e/ctl"
#=======================================================================
echo e/emft
cat >e/emft <<"ENDOF e/emft"
#!/bin/csh -f
# ======================================================================
   if($#argv != 2) then
echo "Usage: {e/emft} {ezd-map} {scale}" ; exit
   endif
set MAP=${1}
   if(! -e ${MAP}) then
echo "No map with this name = ${MAP}" ; exit
   endif

# ======================================================================
sed -e "s/SCALE/${2}/" <<"EOF" >! LisT
BEGIN { S = SCALE }
{ printf "%9.3f%9.3f%9.3f%7.3f%7.3f%7.3f   CELDA\n", S*$1,S*$2,S*$3,$4,$5,$6 }
"EOF"
set cell=`head -20 ${MAP} |grep "CELL" |sed -e "s/CELL//" |awk -f LisT -`

$URO/$BIN/e2d <<EOF | egrep -e " set mr |CELDA" >! LisT
${MAP}
${cell}
BoX.e2d
EOF

set STOP=`awk '{if($7 !~ /CELDA/){print 0}}' LisT`
   if($STOP == 0) then
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ">>>>>>>>>>>>>>>>>>>>>> problem with EZD map <<<<<<<<<<<<<<<<<<<<<<<<"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
cat LisT ; rm -f LisT BoX.e2d ; exit
   endif

# ======================================================================
set cell=`cat LisT`
sed -e "s/.*CELDA.*/CELDA/" d/data.d >! LisT
set STOP=`grep CELDA LisT`
   if($STOP != "CELDA") then
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ">>>>>>>>>>>>>>>>>>>>> no CELDA card in data.d <<<<<<<<<<<<<<<<<<<<<<"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
rm -f LisT ; exit
   endif

sed -e "/CELDA/s/CELDA/${cell}/" LisT >! d/data.d
set res=`grep "resolution range" d/data.d`
rm -f LisT

# ======================================================================
source $URO/$BIN/entorno
rm -f fort.* >&/dev/null
ln -s $cwd/BoX.e2d fort.1
ln -s $cwd/d/hkl.d fort.2
$UROS/stfing.exe <<EOF
stfing :
 ** URO **
${cell}
x,y,z * end
${res}
0                        ; (0=no ref-file)
0.                       ; additive b-fact.
hkl                      ; ='hkl' or ='udi'
EOF
rm -rf $UROF fort.* BoX.e2d

   if(! -e d/hkl.d) then
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ">>>>>>>>>>>>>>>>>>>>>> problem of SAMPLING <<<<<<<<<<<<<<<<<<<<<<<<<"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" ; exit
   endif

# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/d/data.d   $UROF/fort.8
ln -s $cwd/i/oicfd.i2 $UROF/fort.10
ln -s $cwd/i/sort.i1  $UROF/fort.11
ln -s $cwd/i/tabl.i1  $UROF/fort.12
$UROX/uro.exe < $cwd/i/dato.i3
rm -rf $UROF

source $URO/$BIN/entorno
ln -s $cwd/d/hkl.d  $UROF/fort.1
ln -s $cwd/f/xudi   $UROF/fort.10
ln -s $cwd/o/sort.s $UROF/fort.9
$UROX/uro.exe < $cwd/i/sort.i1
rm -rf $UROF d/hkl.d

# ======================================================================
if(! -e d/emap.d) echo "WARNING: no link to emap.d"

# ======================================================================
exit
"ENDOF e/emft"
#=======================================================================
echo e/fiting
cat >e/fiting <<"ENDOF e/fiting"
#!/bin/csh -f
# ======================================================================
   if($#argv != 2) then
echo "Usage: {e/fiting} i/{fiting-in}.i1 o/{fiting-out}.s" ; exit
   endif
# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/f/xudi $UROF/fort.10
ln -s $cwd/o/$2.s $UROF/fort.9
set n="1"
   while ($n <= 100)
      if(-e $cwd/f/tabl$n) then
set m=`expr $n + 10`
ln -s $cwd/f/tabl$n $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$UROX/uro.exe < $cwd/i/$1.i1
rm -rf $UROF
exit
"ENDOF e/fiting"
#=======================================================================
echo e/job
cat >e/job <<"ENDOF e/job"
#!/bin/csh -f
# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/d/data.d   $UROF/fort.8
ln -s $cwd/i/oicfd.i2 $UROF/fort.10
ln -s $cwd/i/sort.i1  $UROF/fort.11
ln -s $cwd/i/tabl.i1  $UROF/fort.12
$UROX/uro.exe < $cwd/i/dato.i3
rm -rf $UROF
exit
"ENDOF e/job"
#=======================================================================
echo e/oic
cat >e/oic <<"ENDOF e/oic"
#!/bin/csh -f
# ======================================================================
   if($#argv < 2) then
echo "Usage: {e/oic} o/{fiting-out}.s i/{fiting-in}.i1 [ncycl] [niter]" ; exit
   endif
   if($#argv == 2) then
set ncycl="1"
set niter="10"
   else if($#argv == 3) then
set ncycl=${3}
set niter="10"
   else if($#argv == 4) then
set ncycl=${3}
set niter=${4}
   endif
   if(! -e o/${1}.s) then
echo "No fiting output with this name = o/${1}.s" ; exit
   endif
#****************** needs SYMlist **************************************
   if(! -e symlist) then
echo "NEED symlist FILE" ; exit
   endif

# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/o/${1}.s  $UROF/fort.1
ln -s $cwd/i/${2}.i1 $UROF/fort.9
set n="1"
      while ($n <= 100)
   if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
   endif
set n=`expr $n + 1`
      end
ln -s $cwd/d/data.d $UROF/fort.8
$UROX/uro.exe < $cwd/i/oicfd.i2 >/dev/null
rm -rf $UROF

echo end >> i/${2}.i1

# ======================================================================
source $URO/$BIN/entorno
cat >! LisT <<"EOF"
{
   if($1 !~ /inertia/)
      print
   else
      exit
}
"EOF"
awk -f LisT i/${2}.i1 >! $UROF/fit.i1
rm -rf LisT

# ======================================================================
# generates symmetry operations to apply to the independent molecules in
# the working cell. transforms symmetry operations into fractional and
# subtracts the origin.
set SYM=d/sym

echo `grep "CELDA" d/data.d` `head -20 d/emap.d | egrep -e "ORIGIN|EXTENT"` >! LisT
cat >! LisT1 <<"EOF"
{ printf "A=%8.3f;B=%8.3f;C=%8.3f;TX=%3d/%-3d;TY=%3d/%-3d;TZ=%3d/%-3d\n",\
 $1,$2,$3,$9,$13,$10,$14,$11,$15 }
"EOF"
awk -f LisT1 LisT |sed -e "s/\//\\\//g" >! LisT2
set line=`cat LisT2`
rm -f LisT LisT1 LisT2

echo -n >! LisT1
set num="0"
   foreach sym (`cat symlist`)
egrep -e "#${sym}"$ $SYM >> LisT1
set num=`expr ${num} + 1`
   end

sed -e "/LINE/s/LINE/${line}/" <<"EOF" |sed -e "/NUMB/s/NUMB/${num}/" >! LisT2
BEGIN { LINE ; printf "ncs %5d\n",NUMB }
{ printf " %8.2f%8.2f%8.2f%10.5f%10.5f%10.5f      %s\n", \
       $1,$2,$3,$4/A-TX,$5/B-TY,$6/C-TZ,$7 }
"EOF"
awk -f LisT2 LisT1 >> $UROF/fit.i1
rm -f LisT1 LisT2

# ======================================================================
cat >! LisT <<"EOF"
{
   if($1 == "inertia")
   {
      print
      getline
      while ($1 !~ /end/)
      {
         print
         getline
      }
      exit
   }
}
"EOF"
awk -f LisT i/${2}.i1 >> $UROF/fit.i1

sed -e "/printing/s/2    1 1    /4    1 1 0 1/" $UROF/fit.i1 | \
sed -e "/ 0 1 1 1 /s/ 0 0 0 / 1 1 1 /" | \
sed -e "/ 0        20 /s/ 0        20     0./ ${ncycl} ${niter} 0.0/" >! i/${2}.i1
rm -rf LisT $UROF
exit
"ENDOF e/oic"
#=======================================================================
echo e/oic_fiting
cat >e/oic_fiting <<"ENDOF e/oic_fiting"
#!/bin/csh -f
# ======================================================================
   if($#argv < 2) then
echo "Usage: {e/oic_fiting} o/{fiting-inp}.s o/{fiting-out}.s [ncycl] [niter]" ; exit
   endif
   if($#argv == 2) then
set ncycl="1"
set niter="10"
   else if($#argv == 3) then
set ncycl=${3}
set niter="10"
   else if($#argv == 4) then
set ncycl=${3}
set niter=${4}
   endif
   if(! -e o/${1}.s) then
echo "No fiting output with this name = o/${1}.s" ; exit
   endif
#****************** needs SYMlist **************************************
   if(! -e symlist) then
echo "NEED symlist FILE" ; exit
   endif

# ======================================================================
$cwd/e/oic ${1} fit ${ncycl} ${niter}; $cwd/e/fiting fit ${2}
exit
"ENDOF e/oic_fiting"
#=======================================================================
echo e/pv2c
cat >e/pv2c <<"ENDOF e/pv2c"
#!/bin/csh -f
# ======================================================================
   if($#argv != 1) then
echo "Usage: {e/pv2c} o/{fiting-out}.s" ; exit
   endif
   if(! -e o/${1}.s) then
echo "No fiting output with this name = o/${1}.s" ; exit
   endif
#****************** needs MODlist **************************************
   if(! -e modlist) then
echo "NEED modlist FILE" ; exit
   endif
grep "\#" modlist | sed -e "s/#//" >! LisT
cat >! LisT1 <<"EOF"
{
  # construct a string of fields from $2 to $(NF)
  fields = " ";
  for(i=2; i<=NF; i++) fields = sprintf("%s%3s", fields, $i);  #
  if($1 in table)  table[$1] = sprintf("%s%s", table[$1], fields);
  else  table[$1] = $0;
}
END { for(i in table)  printf("%s\n", table[i]); }
"EOF"
awk -f LisT1 LisT >! listmod
rm -rf LisT LisT1

# ======================================================================
sed -e "s/^[ ]*[0-9]*//" listmod >! LisT
set n="0"
   while (-e BUNDLED_INI_${n}.pdb)
set n=`expr $n + 1`
   end
   foreach MOL (`cat LisT`)
      if(-e ${MOL}.pdb) then
echo "#========================================" >> BUNDLED_INI_${n}.pdb
echo "echo ${MOL}.pdb"  >> BUNDLED_INI_${n}.pdb
set nom=(\"ENDOF ${MOL}.pdb\")
echo "cat >${MOL}.pdb <<"$nom >> BUNDLED_INI_${n}.pdb
cat ${MOL}.pdb >> BUNDLED_INI_${n}.pdb
echo $nom >> BUNDLED_INI_${n}.pdb
      endif
   end
rm -f LisT

# ======================================================================
# restaura el shift y genera mol#_1
$URO/$BIN/a2c <<EOF >/dev/null
$cwd/o/${1}.s
x
1

EOF
csh x
rm -f LisT x

# ======================================================================
# copia las mol#_1 en [A-Z].pdb
sed -e "s/^[ ]*[0-9]*//" listmod >! LisT
set m=0
   foreach MOL (`cat LisT`)
set m=`expr $m + 1`
echo mol${m}_1 ">>>" ${MOL}.pdb
cp mol${m}_1 ${MOL}.pdb
   end
rm -f LisT listmod mol*_1
exit
"ENDOF e/pv2c"
#=======================================================================
echo e/scat
cat >e/scat <<"ENDOF e/scat"
#!/bin/csh -f
# ======================================================================
   if($#argv != 1) then
echo "Usage: {e/scat} {model-nb}" ; exit
   endif
   if(! -e $cwd/d/xyz${1}.d && ! -e $cwd/d/map${1}.d) then
echo "No model with this number = ${1}" ; exit
   endif
   if(! -e $cwd/i/tabl.i1) then
echo "Must first execute e/emft or e/job" ; exit
   endif
# ======================================================================
source $URO/$BIN/entorno
ln -s $cwd/d/xyz${1}.d  $UROF/fort.1
ln -s $cwd/d/map${1}.d  $UROF/fort.2
ln -s $URO/factor.d     $UROF/fort.3
ln -s $cwd/f/tabl${1}   $UROF/fort.10
ln -s $cwd/o/tabl${1}.s $UROF/fort.9
sed -e "/Fourier/s/^/model "${1}" - /" $cwd/i/tabl.i1 > $UROF/tabl.i1
$UROX/uro.exe < $UROF/tabl.i1
rm -rf $UROF
exit
"ENDOF e/scat"
#=======================================================================
echo i/dato.i3
cat >i/dato.i3 <<"ENDOF i/dato.i3"
job  +*+*+*+*+*+*+*+*+*
xyz               model type
1000              nb. trans. to fit (big because of ncs_rms)
0.                CoM cutoff
"ENDOF i/dato.i3"
#=======================================================================
cp $URO/maitre.scr e/maitre.scr
chmod +x ncs_rms splits go.* go_instance.O e/* d/*.scr
exit
